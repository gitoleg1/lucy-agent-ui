"use client";

import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import styles from "./TaskStreamViewer.module.css";

/**
 * TaskStreamViewer
 * - מושך את כתובת ה-API מה-UI (/api/ping)
 * - מאפשר להתחבר ל-WebSocket ולהציג הודעות/אירועים זורמים
 * - שומר על ניקיון התלויות כך שלא תופיע אזהרת react-hooks/exhaustive-deps
 */

type WsMessage =
  | { type: "info"; message: string }
  | { type: "event"; message: string }
  | { type: "error"; message: string };

export default function TaskStreamViewer() {
  const [apiBase, setApiBase] = useState<string>("");
  const [connecting, setConnecting] = useState(false);
  const [connected, setConnected] = useState(false);
  const [messages, setMessages] = useState<WsMessage[]>([]);
  const wsRef = useRef<WebSocket | null>(null);

  // נקראת פעם אחת: מביאה את בסיס ה-API מתוך /api/ping של ה-UI
  useEffect(() => {
    let aborted = false;

    async function loadPing() {
      try {
        const res = await fetch("/api/ping", { cache: "no-store" });
        if (!res.ok) throw new Error(`ping failed with ${res.status}`);
        const data = await res.json();
        // אם קיים שדה base נשתמש בו, אחרת נשאיר ריק
        if (!aborted && typeof data?.base === "string") {
          setApiBase(data.base);
        }
      } catch (err) {
        console.error(err);
        if (!aborted) {
          // לא עוצרים את הדף, רק נציג הודעת מידע
          setMessages((prev) => [
            ...prev,
            { type: "error", message: "Failed to read /api/ping. Using default." },
          ]);
        }
      }
    }

    loadPing();
    return () => {
      aborted = true;
    };
  }, []);

  // גוזרים את כתובת ה-WS מה-apiBase. אם חסר, ננסה "ws(s)://host"
  const wsUrl = useMemo(() => {
    // אם ping החזיר http://127.0.0.1:8000 למשל – נהפוך ל-ws://127.0.0.1:8000/ws
    if (apiBase.startsWith("http://")) return apiBase.replace("http://", "ws://") + "/ws";
    if (apiBase.startsWith("https://")) return apiBase.replace("https://", "wss://") + "/ws";

    // fallback: אותו host של ה-UI (עבור dev ריץ' פרוקסי)
    if (typeof window !== "undefined") {
      const proto = window.location.protocol === "https:" ? "wss:" : "ws:";
      const host = window.location.host;
      return `${proto}//${host}/ws`;
    }
    return "ws://localhost:8000/ws";
  }, [apiBase]);

  // פונקציית התחברות — עוטפים ב-useCallback ומחזיקים את כל התלויות
  const connect = useCallback(() => {
    if (connected || connecting) return;
    setConnecting(true);

    try {
      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;

      ws.onopen = () => {
        setConnecting(false);
        setConnected(true);
        setMessages((prev) => [...prev, { type: "info", message: "WebSocket connected" }]);
      };

      ws.onmessage = (ev) => {
        try {
          const parsed = JSON.parse(ev.data);
          if (typeof parsed?.message === "string") {
            setMessages((prev) => [...prev, { type: "event", message: parsed.message }]);
          } else {
            setMessages((prev) => [...prev, { type: "event", message: ev.data }]);
          }
        } catch {
          setMessages((prev) => [...prev, { type: "event", message: String(ev.data) }]);
        }
      };

      ws.onerror = () => {
        setMessages((prev) => [...prev, { type: "error", message: "WebSocket error" }]);
      };

      ws.onclose = () => {
        setConnected(false);
        setMessages((prev) => [...prev, { type: "info", message: "WebSocket closed" }]);
      };
    } catch (err) {
      console.error(err);
      setConnecting(false);
      setMessages((prev) => [...prev, { type: "error", message: "Failed to open WebSocket" }]);
    }
  }, [wsUrl, connected, connecting]);

  const disconnect = useCallback(() => {
    if (wsRef.current && (wsRef.current.r
